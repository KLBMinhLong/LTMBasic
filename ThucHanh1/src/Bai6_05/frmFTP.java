/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package Bai6_05;

import java.io.*;
import java.net.*;
import javax.swing.*;
import java.nio.file.*;

/**
 *
 * @author Admin
 */
public class frmFTP extends javax.swing.JFrame {
    
    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(frmFTP.class.getName());
    private static final int PACKET_SIZE = 1024; // Kích thước mỗi packet data
    private static final int TIMEOUT = 2000; // Timeout 2 giây
    private DatagramSocket receiveSocket;
    private Thread receiveThread;
    private boolean isReceiving = false;
    private File selectedFile;

    /**
     * Creates new form frmFTP
     */
    public frmFTP() {
        initComponents();
        setLocationRelativeTo(null);
        
        // Đặt thư mục mặc định là Downloads hoặc user home
        String defaultFolder = System.getProperty("user.home") + File.separator + "Downloads";
        File downloads = new File(defaultFolder);
        if (!downloads.exists()) {
            defaultFolder = System.getProperty("user.home");
        }
        txtSaveFolder.setText(defaultFolder);
        
        log("Chương trình FTP sử dụng UDP Socket đã khởi động.");
        log("Thư mục lưu file: " + defaultFolder);
    }
    
    private void log(String message) {
        txtLog.append(message + "\n");
        txtLog.setCaretPosition(txtLog.getDocument().getLength());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        txtFilePath = new javax.swing.JTextField();
        btnBrowse = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        txtDestIP = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        txtDestPort = new javax.swing.JTextField();
        btnSendFile = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        txtReceivePort = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        txtSaveFolder = new javax.swing.JTextField();
        btnChooseFolder = new javax.swing.JButton();
        btnStartReceive = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtLog = new javax.swing.JTextArea();
        progressBar = new javax.swing.JProgressBar();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("FTP sử dụng UDP Socket");

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Gửi File"));

        jLabel1.setText("Chọn file:");

        txtFilePath.setEditable(false);

        btnBrowse.setText("Chọn File");
        btnBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnBrowseActionPerformed(evt);
            }
        });

        jLabel2.setText("IP đích:");

        txtDestIP.setText("localhost");

        jLabel3.setText("Port:");

        txtDestPort.setText("9999");

        btnSendFile.setText("Gửi File");
        btnSendFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendFileActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtFilePath, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtDestIP, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(20, 20, 20)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtDestPort, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(btnSendFile, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(txtFilePath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnBrowse))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(txtDestIP, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3)
                    .addComponent(txtDestPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnSendFile))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Nhận File"));

        jLabel4.setText("Port lắng nghe:");

        txtReceivePort.setText("9999");

        jLabel5.setText("Lưu tại:");

        txtSaveFolder.setEditable(false);

        btnChooseFolder.setText("Chọn Thư Mục");
        btnChooseFolder.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnChooseFolderActionPerformed(evt);
            }
        });

        btnStartReceive.setText("Bắt Đầu Nhận");
        btnStartReceive.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStartReceiveActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(txtReceivePort, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(20, 20, 20)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(txtSaveFolder, javax.swing.GroupLayout.DEFAULT_SIZE, 240, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnChooseFolder, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(20, 20, 20)
                .addComponent(btnStartReceive, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(txtReceivePort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5)
                    .addComponent(txtSaveFolder, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnChooseFolder)
                    .addComponent(btnStartReceive))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        txtLog.setEditable(false);
        txtLog.setColumns(20);
        txtLog.setRows(5);
        jScrollPane1.setViewportView(txtLog);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 650, Short.MAX_VALUE)
                    .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(20, 20, 20))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(15, 15, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnBrowseActionPerformed
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Chọn file để gửi");
        
        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            selectedFile = fileChooser.getSelectedFile();
            txtFilePath.setText(selectedFile.getAbsolutePath());
            log("Đã chọn file: " + selectedFile.getName() + " (" + selectedFile.length() + " bytes)");
        }
    }//GEN-LAST:event_btnBrowseActionPerformed

    private void btnSendFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendFileActionPerformed
        if (selectedFile == null || !selectedFile.exists()) {
            JOptionPane.showMessageDialog(this, "Vui lòng chọn file trước!", "Lỗi", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        String destIP = txtDestIP.getText().trim();
        int destPort;
        
        try {
            destPort = Integer.parseInt(txtDestPort.getText().trim());
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(this, "Port không hợp lệ!", "Lỗi", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        // Gửi file trong thread riêng
        new Thread(() -> sendFile(selectedFile, destIP, destPort)).start();
    }//GEN-LAST:event_btnSendFileActionPerformed

    private void btnChooseFolderActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnChooseFolderActionPerformed
        JFileChooser folderChooser = new JFileChooser();
        folderChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        folderChooser.setDialogTitle("Chọn thư mục lưu file");
        
        int result = folderChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            File folder = folderChooser.getSelectedFile();
            txtSaveFolder.setText(folder.getAbsolutePath());
            log("Thư mục lưu file: " + folder.getAbsolutePath());
        }
    }//GEN-LAST:event_btnChooseFolderActionPerformed

    private void btnStartReceiveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnStartReceiveActionPerformed
        if (!isReceiving) {
            // Bắt đầu nhận
            int port;
            try {
                port = Integer.parseInt(txtReceivePort.getText().trim());
            } catch (NumberFormatException e) {
                JOptionPane.showMessageDialog(this, "Port không hợp lệ!", "Lỗi", JOptionPane.ERROR_MESSAGE);
                return;
            }
            
            startReceiving(port);
        } else {
            // Dừng nhận
            stopReceiving();
        }
    }//GEN-LAST:event_btnStartReceiveActionPerformed

    private void sendFile(File file, String destIP, int destPort) {
        DatagramSocket socket = null;
        FileInputStream fis = null;
        
        try {
            log("Bắt đầu gửi file: " + file.getName());
            socket = new DatagramSocket();
            socket.setSoTimeout(TIMEOUT);
            
            InetAddress address = InetAddress.getByName(destIP);
            fis = new FileInputStream(file);
            
            // Gửi header: tên file và kích thước
            String header = "FILE:" + file.getName() + ":" + file.length();
            byte[] headerData = header.getBytes();
            DatagramPacket headerPacket = new DatagramPacket(headerData, headerData.length, address, destPort);
            socket.send(headerPacket);
            log("Đã gửi header: " + header);
            
            // Chờ ACK header
            byte[] ackBuffer = new byte[10];
            DatagramPacket ackPacket = new DatagramPacket(ackBuffer, ackBuffer.length);
            socket.receive(ackPacket);
            String ackMsg = new String(ackPacket.getData(), 0, ackPacket.getLength());
            if (!ackMsg.equals("ACK_HEADER")) {
                log("Không nhận được ACK header!");
                return;
            }
            
            // Gửi file theo từng packet
            long fileSize = file.length();
            long totalPackets = (fileSize + PACKET_SIZE - 1) / PACKET_SIZE;
            byte[] buffer = new byte[PACKET_SIZE];
            int packetNum = 0;
            int bytesRead;
            
            SwingUtilities.invokeLater(() -> {
                progressBar.setMaximum((int)totalPackets);
                progressBar.setValue(0);
            });
            
            while ((bytesRead = fis.read(buffer)) != -1) {
                // Tạo packet: [PACKET_NUM][DATA]
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                DataOutputStream dos = new DataOutputStream(baos);
                dos.writeInt(packetNum);
                dos.write(buffer, 0, bytesRead);
                
                byte[] packetData = baos.toByteArray();
                DatagramPacket dataPacket = new DatagramPacket(packetData, packetData.length, address, destPort);
                
                boolean acked = false;
                int retries = 0;
                
                while (!acked && retries < 5) {
                    socket.send(dataPacket);
                    
                    try {
                        ackBuffer = new byte[20];
                        ackPacket = new DatagramPacket(ackBuffer, ackBuffer.length);
                        socket.receive(ackPacket);
                        
                        String ack = new String(ackPacket.getData(), 0, ackPacket.getLength());
                        if (ack.equals("ACK:" + packetNum)) {
                            acked = true;
                            final int currentPacket = packetNum;
                            SwingUtilities.invokeLater(() -> progressBar.setValue(currentPacket + 1));
                        }
                    } catch (SocketTimeoutException e) {
                        retries++;
                        log("Timeout packet " + packetNum + ", retry " + retries);
                    }
                }
                
                if (!acked) {
                    log("Không thể gửi packet " + packetNum + " sau 5 lần thử!");
                    return;
                }
                
                packetNum++;
            }
            
            // Gửi END signal
            String endMsg = "END:" + packetNum;
            byte[] endData = endMsg.getBytes();
            DatagramPacket endPacket = new DatagramPacket(endData, endData.length, address, destPort);
            socket.send(endPacket);
            
            log("Hoàn tất gửi file! Tổng số packets: " + packetNum);
            SwingUtilities.invokeLater(() -> progressBar.setValue((int)totalPackets));
            
        } catch (Exception e) {
            log("Lỗi khi gửi file: " + e.getMessage());
            e.printStackTrace();
        } finally {
            try {
                if (fis != null) fis.close();
                if (socket != null) socket.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    private void startReceiving(int port) {
        try {
            receiveSocket = new DatagramSocket(port);
            isReceiving = true;
            btnStartReceive.setText("Dừng Nhận");
            txtReceivePort.setEnabled(false);
            log("Đang lắng nghe trên port " + port + "...");
            
            receiveThread = new Thread(() -> receiveFile());
            receiveThread.start();
            
        } catch (Exception e) {
            log("Lỗi khi khởi động server: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void stopReceiving() {
        isReceiving = false;
        if (receiveSocket != null && !receiveSocket.isClosed()) {
            receiveSocket.close();
        }
        btnStartReceive.setText("Bắt Đầu Nhận");
        txtReceivePort.setEnabled(true);
        log("Đã dừng nhận file.");
    }
    
    private void receiveFile() {
        while (isReceiving) {
            FileOutputStream fos = null;
            String fileName = null;
            long fileSize = 0;
            int expectedPacket = 0;
            
            try {
                // Nhận header
                byte[] headerBuffer = new byte[1024];
                DatagramPacket headerPacket = new DatagramPacket(headerBuffer, headerBuffer.length);
                receiveSocket.receive(headerPacket);
                
                String header = new String(headerPacket.getData(), 0, headerPacket.getLength());
                if (header.startsWith("FILE:")) {
                    String[] parts = header.split(":");
                    fileName = parts[1];
                    fileSize = Long.parseLong(parts[2]);
                    
                    log("Đang nhận file: " + fileName + " (" + fileSize + " bytes)");
                    
                    // Gửi ACK header
                    byte[] ackData = "ACK_HEADER".getBytes();
                    DatagramPacket ackPacket = new DatagramPacket(
                        ackData, 
                        ackData.length, 
                        headerPacket.getAddress(), 
                        headerPacket.getPort()
                    );
                    receiveSocket.send(ackPacket);
                    
                    // Tạo file để lưu
                    String saveFolder = txtSaveFolder.getText();
                    File folder = new File(saveFolder);
                    
                    // Tạo thư mục nếu chưa tồn tại
                    if (!folder.exists()) {
                        if (folder.mkdirs()) {
                            log("Đã tạo thư mục: " + saveFolder);
                        } else {
                            log("Lỗi: Không thể tạo thư mục " + saveFolder);
                            continue;
                        }
                    }
                    
                    String savePath = saveFolder + File.separator + fileName;
                    fos = new FileOutputStream(savePath);
                    
                    long totalPackets = (fileSize + PACKET_SIZE - 1) / PACKET_SIZE;
                    SwingUtilities.invokeLater(() -> {
                        progressBar.setMaximum((int)totalPackets);
                        progressBar.setValue(0);
                    });
                    
                    // Nhận các packet dữ liệu
                    while (true) {
                        byte[] buffer = new byte[PACKET_SIZE + 100];
                        DatagramPacket dataPacket = new DatagramPacket(buffer, buffer.length);
                        receiveSocket.receive(dataPacket);
                        
                        byte[] receivedData = dataPacket.getData();
                        int length = dataPacket.getLength();
                        
                        // Kiểm tra END signal
                        String msg = new String(receivedData, 0, Math.min(20, length));
                        if (msg.startsWith("END:")) {
                            log("Nhận được END signal");
                            break;
                        }
                        
                        // Đọc packet number và data
                        ByteArrayInputStream bais = new ByteArrayInputStream(receivedData, 0, length);
                        DataInputStream dis = new DataInputStream(bais);
                        int packetNum = dis.readInt();
                        byte[] fileData = new byte[length - 4];
                        dis.read(fileData);
                        
                        if (packetNum == expectedPacket) {
                            fos.write(fileData);
                            expectedPacket++;
                            
                            final int current = packetNum;
                            SwingUtilities.invokeLater(() -> progressBar.setValue(current + 1));
                            
                            // Gửi ACK
                            String ackMsg = "ACK:" + packetNum;
                            ackData = ackMsg.getBytes();
                            ackPacket = new DatagramPacket(
                                ackData, 
                                ackData.length, 
                                dataPacket.getAddress(), 
                                dataPacket.getPort()
                            );
                            receiveSocket.send(ackPacket);
                        } else {
                            log("Nhận packet không đúng thứ tự: " + packetNum + " (mong đợi " + expectedPacket + ")");
                        }
                    }
                    
                    log("Hoàn tất nhận file: " + fileName + " - Lưu tại: " + savePath);
                    SwingUtilities.invokeLater(() -> progressBar.setValue((int)totalPackets));
                }
                
            } catch (SocketException e) {
                if (isReceiving) {
                    log("Lỗi socket: " + e.getMessage());
                }
                break;
            } catch (Exception e) {
                log("Lỗi khi nhận file: " + e.getMessage());
                e.printStackTrace();
            } finally {
                try {
                    if (fos != null) fos.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ReflectiveOperationException | javax.swing.UnsupportedLookAndFeelException ex) {
            logger.log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> new frmFTP().setVisible(true));
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnBrowse;
    private javax.swing.JButton btnChooseFolder;
    private javax.swing.JButton btnSendFile;
    private javax.swing.JButton btnStartReceive;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JTextField txtDestIP;
    private javax.swing.JTextField txtDestPort;
    private javax.swing.JTextField txtFilePath;
    private javax.swing.JTextArea txtLog;
    private javax.swing.JTextField txtReceivePort;
    private javax.swing.JTextField txtSaveFolder;
    // End of variables declaration//GEN-END:variables
}
